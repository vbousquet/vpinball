////GLOBAL
#version 430

////DEFINES
#define NUM_BALL_LIGHTS 8

#include "Helpers.fxh"

uniform mat4 orientation;

layout(std140) uniform ballMatrixBlock {
	mat4 matView;
	mat4 matWorldView;
	mat4 matWorldViewInverse;
	mat4 matWorldViewProj[N_EYES];
};

uniform mat4 matProj[N_EYES]; // Separated from matrix block since we only need to set it once per frame (same for all balls)

////VERTEX
layout(location=0) in vec3 vPosition;
layout(location=1) in vec3 vNormal;
layout(location=2) in vec2 tex0;

uniform vec4 clip_plane; // Clip plane defined in table coordinate system
uniform int layer; // Layer being rendered (set to 0 is using layered rendering, that is to say rendering multiple layers using instanced rendering)

VS_OUT_EYE;

////GEOMETRY
layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

in int eye_gs[];

////FRAGMENT

// Early-Z-test implementation:
#extension GL_ARB_shader_image_load_store : enable
#extension GL_ARB_conservative_depth : enable
#if !defined(SHADER_GL410) && !defined(SHADER_GLES30)
layout(early_fragment_tests) in;
layout(depth_unchanged) out float gl_FragDepth;
#endif

uniform sampler2D tex_ball_color; // base texture
uniform samplerStereo tex_ball_playfield; // playfield
uniform sampler2D tex_ball_decal; // ball decal
uniform sampler2D brdfLUT; // Precomputed BRDF LUT

uniform sampler2D tex_env; // envmap
uniform sampler2D tex_diffuse_env; // envmap radiance

#include "Material_GL.fxh"

uniform float4  invTableRes_playfield_height_reflection;
uniform float4  w_h_disableLighting;
#define disableLighting (w_h_disableLighting.z != 0.)

out vec4 color;

////vsBall
VS_OUT(vec4, normal_t0x);
VS_OUT(vec4, worldPos_t0y);

void main()
{
    // apply spinning and move the ball to it's actual position
    float4 pos = vec4(vPosition, 1.0);
    pos.xyz = (orientation * pos).xyz;

    // apply spinning to the normals too to get the sphere mapping effect
    const float3 nspin = (orientation * vec4(vNormal,0.0)).xyz;
    // Needs to use a 'normal' matrix, and to normalize since we allow non uniform stretching, therefore matWorldView is not orthonormal
    const float3 normal = normalize((vec4(nspin, 0.0) * matWorldViewInverse).xyz); // actually: mul(vec4(nspin,0.), matWorldViewInverseTranspose), but optimized to save one matrix

    const float3 p = (matWorldView * pos).xyz;

    VS_EYE;
    VS_POSITION(matWorldViewProj[eye_vs] * pos, pos);
    VS_VARYING(normal_t0x, float4(normal,tex0.x));
    VS_VARYING(worldPos_t0y, float4(p,tex0.y));
    VS_CLIP_DISTANCE(pos);
}

////vsBallTrail
VS_OUT(vec3, tex0_alpha);

void main()
{
    float4 pos = vec4(vPosition, 1.0);
    VS_EYE;
    VS_POSITION(matWorldViewProj[eye_vs] * pos, pos);
    VS_VARYING(tex0_alpha, float3(tex0, vNormal.x)); //!! abuses normal for now
    VS_CLIP_DISTANCE(pos);
}

////gsBall

in vec4 normal_t0x_gs[];
out vec4 normal_t0x;

in vec4 worldPos_t0y_gs[];
out vec4 worldPos_t0y;

flat out float eye;

void main()
{
    gl_Layer = eye_gs[0];
    for (int i=0;i<gl_in.length();i++) {
        gl_Position = (matWorldViewProj[eye_gs[i]]*gl_in[i].gl_Position);
        gl_ClipDistance[0] = gl_in[i].gl_ClipDistance[0];
        normal_t0x = normal_t0x_gs[i];
        worldPos_t0y = worldPos_t0y_gs[i];
        eye = eye_gs[i];
        EmitVertex();
    }
    EndPrimitive();
}

////gsBallTrail

in vec3 tex0_alpha_gs[];
out vec3 tex0_alpha;

void main()
{
    gl_Layer = eye_gs[0];
    for (int i=0;i<gl_in.length();i++) {
        gl_Position = (matWorldViewProj[eye_gs[i]]*gl_in[i].gl_Position);
        tex0_alpha = tex0_alpha_gs[i];
        EmitVertex();
    }
    EndPrimitive();
}

////FRAGMENT

////psBall

in vec4 normal_t0x;
in vec4 worldPos_t0y;
flat in float eye;


float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
	
    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
	
    return num / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);
	
    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

vec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

void main()
{
    const float3 V = normalize(/*camera=0,0,0,1*/-worldPos_t0y.xyz);
    const float3 N = normalize(normal_t0x.xyz);
    const float3 R = reflect(V, N);

	// Compute environment specular reflection from the ball_color texture (which is an environment map) and the previous frame (which is a reflection probe)

    float3 environmentColor;
    const float edge = dot(V, R);
    // edge falloff to reduce aliasing on edges (picks smaller mipmap -> more blur)
    const float lod = (edge > 0.6) ? edge*(6.0*1.0/0.4)-(6.0*0.6/0.4) : 0.0;
    BRANCH if (%PARAM0%) // equirectangularMap
    { // Equirectangular Map Reflections
      // trafo back to world for lookup into world space envmap
      // matView is always an orthonormal matrix, so no need to normalize after transform
      const float3 rv = /*normalize*/((float4(-R,0.0) * matView).xyz);
      const float2 uv = ray_to_equirectangular_uv(rv);
      environmentColor = textureLod(tex_ball_color, uv, lod).rgb;
    }
    else
    { // Spherical Map Reflections
      // calculate the intermediate value for the final texture coords. found here http://www.ozone3d.net/tutorials/glsl_texturing_p04.php
      const float m = (1.0 - R.z > 0.) ? 0.3535533905932737622 * rsqrt(1.0 - R.z) : 0.; // 0.353...=0.5/sqrt(2)
      const float2 uv = float2(0.5 - m * R.x, 0.5 - m * R.y);
      environmentColor = textureLod(tex_ball_color, uv, lod).rgb;
    }

    // No need to normalize here since the matWorldView matrix is normal (world is identity and view is always orthonormal)
    // No need to use a dedicated 'normal' matrix since the matWorldView is orthonormal (world is identity and view is always orthonormal)
    //const float3 playfield_normal = normalize((float4(0.,0.,1.,0.) * matWorldViewInverse).xyz); //!! normalize necessary? // actually: mul(float4(0.,0.,1.,0.), matWorldViewInverseTranspose), but optimized to save one matrix
    //const float3 playfield_normal = (matWorldView * float4(0.,0.,1.,0.)).xyz;
    const float3 playfield_normal = matWorldView[2].xyz;
    const float NdotR = dot(playfield_normal, R);

    const float3 playfield_p0 = mul_w1(float3(/*playfield_pos=*/0.,0.,invTableRes_playfield_height_reflection.z), matWorldView);
    const float t = dot(playfield_normal, worldPos_t0y.xyz - playfield_p0) / NdotR;
    const float3 playfield_hit = worldPos_t0y.xyz - t * R;

	// New implementation: use previous frame as a reflection probe instead of computing a simplified render (this is faster and more accurate, support playfield mesh, lighting,... but there can be artefacts, with self reflection,...)
	// TODO use previous frame projection instead of the one of the current frame to limit reflection distortion (still this is minimal)
	const float4 proj = matProj[int(eye)] * float4(playfield_hit, 1.0);
	const float2 uvp = float2(0.5, 0.5) + proj.xy * (0.5 / proj.w);
	const float3 playfieldColor = saturate(0.25 * (
		  texStereo(tex_ball_playfield, uvp + float2(w_h_disableLighting.x, 0.)).rgb
		+ texStereo(tex_ball_playfield, uvp - float2(w_h_disableLighting.x, 0.)).rgb
		+ texStereo(tex_ball_playfield, uvp + float2(0., w_h_disableLighting.y)).rgb
		+ texStereo(tex_ball_playfield, uvp - float2(0., w_h_disableLighting.y)).rgb
	) * invTableRes_playfield_height_reflection.w); // a bit of supersampling, not strictly needed, but a bit better and not that costly

	float weight;
	if (NdotR <= 0.)
		// Reversed reflection => discard
		weight = 0.;
    // we don't clamp sampling outside the playfield (costly and no real visual impact)
	// const float2 uv = (matWorldViewInverse * float4(playfield_hit, 1.0)).xy * invTableRes_playfield_height_reflection.xy;
	// else if (uv.x < 0.1 && uv.y < 0.1 && uv.x > 0.9 && uv.y > 0.9)
	//	weight = 0.;
	else if (uvp.x < 0. || uvp.x > 1. || uvp.y < 0. || uvp.y > 1.)
		// outside of previous render => discard (we could use sampling techniques to optimize a bit)
		weight = 0.;
	else if (t <= 0.)
		// t < 0.0 may happen in some situation where ball intersects the playfield and the reflected point is inside the ball (like in kicker)
		weight = 0.;
	else
		// Default: magic falloff between playfield (down) and environment (up)
		weight = NdotR * NdotR;
	environmentColor = lerp(environmentColor, playfieldColor, weight);

	// Legacy processing for unshaded balls
	const float4 decalColorT = texture(tex_ball_decal, float2(normal_t0x.w, worldPos_t0y.w));
    BRANCH if (disableLighting)
    {
		float3 ballImageColor = environmentColor;
		float3 decalColor = decalColorT.rgb;
		if (!%PARAM1%) // decalMode
		{
		   // decal texture is an alpha scratch texture and must be added to the ball texture
		   // the strength of the scratches totally rely on the alpha values.
		   decalColor *= decalColorT.a;
		   ballImageColor += decalColor;
		}
		else
		   ballImageColor = ScreenHDR(ballImageColor, decalColor);
       color = float4(ballImageColor, cBase_Alpha.a);
       return;
    }

	// More or less a shameless copy/paste from https://learnopengl.com/PBR/Theory
	// Using precomputed BRDF LUT from https://github.com/ImagicTheCat/love-DPBR (MIT licensed)
	
	// material parameters
	float metallic = 0.75; // Keep a bit of diffuse lighting
	float roughness = 0.15; // Searched a value that more or less match the rendering before 10.8
	float ao = 1.; // Not implemented yet
	vec3  albedo;
    if(!%PARAM1%) // decalMode
	{
	   // Scratch texture: alpha leads to high roughness and replace albedo
	   albedo = lerp(cBase_Alpha.rgb, decalColorT.rgb, decalColorT.a);
       roughness = lerp(roughness, 1., decalColorT.a); // FIXME the roughness is not taken in account for the main env reflection, so... we could hack it by playing on the color...
    }
	else
	{
	   // Logo texture: just apply it as the color
	   albedo = ScreenHDR(cBase_Alpha.rgb, decalColorT.rgb);
	}

    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, albedo, metallic);
	           
    // Accumulate contribution from diretc point light (reflectance equation)
    vec3 Lo = vec3(0.0);
    for(int i = 0; i < iLightPointBallsNum; ++i) 
    {
        // calculate per-light radiance
		const float3 lightDir = (matView * float4(lightPos[i].xyz, 1.0)).xyz - worldPos_t0y.xyz;
		const float3 L = normalize(lightDir);
        vec3 H = normalize(V + L);
        float distance    = length(lightDir);
        // const float attenuation = 1.0 / (distance * distance); // We do not use standard falloff but our custom ranged based one
	    const float sqrl_lightDir = dot(lightDir,lightDir); // tweaked falloff to have ranged lightsources
	    float attenuation = saturate(1.0 - sqrl_lightDir*sqrl_lightDir/(cAmbient_LightRange.w*cAmbient_LightRange.w*cAmbient_LightRange.w*cAmbient_LightRange.w)); //!! pre-mult/invert cAmbient_LightRange.w?
	    attenuation = attenuation*attenuation/(sqrl_lightDir + 1.0);
        vec3 radiance     = lightEmission[i].rgb * attenuation;        
        
        // cook-torrance brdf
        float NDF = DistributionGGX(N, H, roughness);        
        float G   = GeometrySmith(N, V, L, roughness);      
        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       
        
        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= 1.0 - metallic;
        
        vec3 numerator    = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
        vec3 specular     = numerator / denominator;  
            
        // add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);                
        Lo += (kD * albedo / PI + specular) * radiance * NdotL; 
    }   

	// Ambient contribution
	vec3 F = FresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);
	vec3 kS = F; 
	vec3 kD = 1.0 - kS;

	// TODO use irradiance from environment but also some approximation for playfield reflections
	// => not a big deal since metallic is nearly 1, wo nearly no diffuse component
	kD *= 1.0 - metallic;
	// TODO we should consider the ball image as the environment and compute its filtered irradiance => overkill ?
    const float3 rv = /*normalize*/((float4(-R,0.0) * matView).xyz);
    const float2 uv = ray_to_equirectangular_uv(rv);
    const float3 irradiance = texNoLod(tex_diffuse_env, uv).rgb * fenvEmissionScale_TexWidth.x;
	vec3 envDiffuse = irradiance * albedo;

	// TODO use prefiltered environment + some approximation for playfield reflections
	// => not really needed for a shiny ball (roughness is nearly 0)
	// const float MAX_REFLECTION_LOD = 4.0;
	// prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;   
	vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), 1.0 - roughness)).rg; // reversed v axis for OpenGL
	vec3 envSpecular = environmentColor * fenvEmissionScale_TexWidth.x * (F * envBRDF.x + envBRDF.y);
	
	vec3 ambient    = (kD * envDiffuse + envSpecular) * ao; 
	
	color.rgb = ambient + Lo;
    color.a = cBase_Alpha.a;
}

////psBallTrail

in vec3 tex0_alpha;

void main()
{
   const float3 ballImageColor = texture(tex_ball_color, tex0_alpha.xy).rgb;
   if (disableLighting)
      color = float4(ballImageColor, tex0_alpha.z);
   else
      color = float4((cBase_Alpha.rgb*(0.075*0.25) + ballImageColor)*fenvEmissionScale_TexWidth.x, tex0_alpha.z); //!! just add the ballcolor in, this is a whacky trail anyhow
}

//------------------------------------
// Techniques

////TECHNIQUES

RenderBall:P0:vsBall():gsBall():psBall(true, false)
RenderBall_DecalMode:P0:vsBall():gsBall():psBall(true, true)
RenderBall_SphericalMap:P0:vsBall():gsBall():psBall(false, false)
RenderBall_SphericalMap_DecalMode:P0:vsBall():gsBall():psBall(false, true)
RenderBallTrail:P0:vsBallTrail():gsBallTrail():psBallTrail()
